
<!DOCTYPE html>
<html class="dark" lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pixel PWA</title>

    <link rel="manifest" href="manifest.webmanifest">
    <meta name="theme-color" content="#1e1b4b">

    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>

    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet" />
    
    <!-- Additional Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Roboto:wght@400;700&family=Open+Sans:wght@400;700&family=Lato:wght@400;700&family=Montserrat:wght@400;700&family=Merriweather:wght@400;700&display=swap" rel="stylesheet">

    <!-- Additional Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Roboto:wght@400;700&family=Open+Sans:wght@400;700&family=Lato:wght@400;700&family=Montserrat:wght@400;700&family=Merriweather:wght@400;700&display=swap" rel="stylesheet">

    <script src="turndown.js"></script>
    <script>
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        "primary": "#4ade80", // Bright Pixel Green
                        "secondary": "#a855f7", // Bright Pixel Purple
                        "background-dark": "#1e1b4b", // Deep Indigo
                        "surface": "#312e81", // Dark Indigo
                        "text-light": "#f0fdf4", // Off-white/Light Green
                        "text-meta": "#a5b4fc", // Lighter Indigo for meta
                        "border-light": "#4f46e5", // Indigo Border
                        "border-dark": "#1e1b4b", // Darker Indigo for inset effect
                        "danger": "#ef4444", // Red
                        "warning": "#f59e0b", // Amber for recording
                    },
                    fontFamily: {
                        "display": ['"Press Start 2P"', "cursive"],
                    },
                    boxShadow: {
                        'pixel-btn': '2px 2px 0px 0px #1e1b4b',
                        'pixel-btn-hover': '3px 3px 0px 0px #1e1b4b',
                        'pixel-container': '4px 4px 0px 0px #1e1b4b',
                        'pixel-container-inset': 'inset 2px 2px 0px 0px #1e1b4b, inset -2px -2px 0px 0px #4f46e5',
                    },
                    borderRadius: {
                        "DEFAULT": "0px",
                    },
                    animation: {
                        'pulse-fast': 'pulse 1s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                },
            },
        }
    </script>

    <style>
        .material-symbols-outlined {
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
            font-size: 1.25rem;
        }

        body {
            min-height: 100vh;
            min-height: 100dvh;
            background-image:
                linear-gradient(rgba(30, 27, 75, 0.8), rgba(30, 27, 75, 0.8)),
                url("data:image/svg+xml,%3Csvg width='6' height='6' viewBox='0 0 6 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23312e81' fill-opacity='0.4' fill-rule='evenodd'%3E%3Cpath d='M5 0h1L0 6V5zM6 5v1H5z'/%3E%3C/g%3E%3C/svg%3E");
        }

        .text-shadow-pixel {
            text-shadow: 1px 1px 0px #1e1b4b;
        }

        /* Page Routing */
        .page {
            display: block;
            min-height: calc(100vh - 120px); /* Full height minus header/nav */
            max-width: 768px; /* Max width for content */
            margin-left: auto;
            margin-right: auto;
        }

        .page.hidden {
            display: none;
        }
        
        /* Unified Form Input */
        .pixel-input {
           @apply h-12 w-full resize-none border-2 border-border-light px-4 shadow-pixel-container-inset focus:outline-none focus:ring-2 focus:ring-inset focus:ring-primary;
           appearance: none;
           background-color: #f0fdf4 !important;
           color: #000000 !important;
           font-size: 0.6rem;
        }
        .pixel-input::placeholder {
            color: #1e1b4b !important;
            opacity: 0.6 !important;
        }

        .pixel-textarea {
           @apply w-full border-2 border-border-light px-4 shadow-pixel-container-inset focus:outline-none focus:ring-2 focus:ring-inset focus:ring-primary;
           padding-top: 0.75rem;
           padding-bottom: 0.75rem;
           background-color: #f0fdf4 !important;
           color: #000000 !important;
           font-size: 0.6rem;
           font-weight: 400;
           white-space: pre-wrap;
           word-wrap: break-word;
           overflow-wrap: break-word;
           word-break: break-all;
           max-width: 100%;
           box-sizing: border-box;
        }
        .pixel-textarea::placeholder {
            color: #1e1b4b !important;
            opacity: 0.6 !important;
        }

        .pixel-textarea b {
            font-weight: 900;
            font-size: 0.7rem;
        }

        [contenteditable][placeholder]:empty:before {
            content: attr(placeholder);
            color: #1e1b4b !important;
            opacity: 0.6 !important;
            pointer-events: none;
            display: block;
        }

        input[type="datetime-local"] {
            color-scheme: light;
        }
        input[type="datetime-local"]::-webkit-calendar-picker-indicator {
            filter: none;
        }

        /* Pixel Button */
        .pixel-button {
            @apply flex items-center justify-center border-4 border-border-dark bg-primary text-background-dark shadow-pixel-container transition-all hover:translate-x-[-2px] hover:translate-y-[-2px] hover:shadow-[6px_6px_0px_0px_#1e1b4b] active:translate-x-[4px] active:translate-y-[4px] active:shadow-none;
        }
        .pixel-button-secondary {
            @apply pixel-button bg-secondary text-text-light;
        }
        .pixel-button-surface {
             @apply flex size-10 cursor-pointer items-center justify-center border-2 border-border-light bg-surface text-text-light shadow-pixel-btn transition-all hover:translate-x-[-1px] hover:translate-y-[-1px] hover:shadow-pixel-btn-hover active:translate-x-[2px] active:translate-y-[2px] active:shadow-none;
        }

        .note-content-display {
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-all;
        }

        .note-content-display img {
            @apply my-4 border-4 border-border-dark shadow-pixel-container;
        }
        .note-content-display ul {
            @apply my-4 list-disc pl-6;
        }
        .note-content-display li {
            @apply mb-2;
        }
        .note-content-display b {
            @apply text-primary;
            font-weight: 900;
            font-size: 0.7rem;
        }
        .note-content-display i {
            @apply text-secondary;
        }
        .note-preview-content {
            display: -webkit-box;
            -webkit-line-clamp: 8;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: normal;
        }
        
        /* Tag styling for clickable effect */
        .tag-chip {
            cursor: pointer;
            transition: transform 0.1s;
        }
        .tag-chip:hover {
            transform: scale(1.05);
        }

        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #4ade80;
            border: 1px solid #1e1b4b;
        }

        .resize-handle-br {
            bottom: -5px;
            right: -5px;
            cursor: se-resize;
        }

        .selected-image {
            border: 2px solid #4ade80;
        }

        .pixel-checkbox {
            @apply shrink-0 appearance-none size-6 border-2 border-border-light bg-surface shadow-pixel-btn checked:bg-primary checked:shadow-pixel-btn-hover;
        }

        /* Drag and Drop Styles */
        .dragging {
            opacity: 0.5;
            background: #4f46e5;
        }
        .drag-over {
            border-top: 2px dashed #4ade80;
        }
        .no-pointer-events * {
            pointer-events: none;
        }

        /* Audio Player Styling */
        audio {
            height: 40px;
            width: 100%;
            border-radius: 0;
            margin-top: 0.5rem;
        }
        
        /* Recording Animation */
        .recording-pulse {
            animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
            background-color: #ef4444; /* danger color */
            border-color: #ef4444;
            color: white;
        }

        /* Compact Mode Overrides */
        body.compact-mode .pixel-button, 
        body.compact-mode .pixel-button-secondary,
        body.compact-mode .pixel-input,
        body.compact-mode .nav-button {
            height: 2.5rem !important;
            font-size: 0.75rem !important;
            line-height: 1rem !important;
        }
        body.compact-mode .nav-button .material-symbols-outlined {
            font-size: 1.5rem;
        }

        /* Background Options */
        body.bg-solid-black { background: #000000 !important; }
        body.bg-solid-gray { background: #1f2937 !important; }
        body.bg-midnight { background: #0f172a !important; }
        body.bg-forest { background: #022c22 !important; }
        body.bg-pattern-grid { 
            background-color: #1e1b4b !important;
            background-image: linear-gradient(#4f46e5 1px, transparent 1px), linear-gradient(90deg, #4f46e5 1px, transparent 1px) !important;
            background-size: 20px 20px !important;
        }
        body.bg-pattern-dots {
            background-color: #1e1b4b !important;
            background-image: radial-gradient(#4f46e5 1px, transparent 1px) !important;
            background-size: 20px 20px !important;
        }

        /* Font Options */
        body.font-sans { font-family: ui-sans-serif, system-ui, sans-serif !important; }
        body.font-serif { font-family: ui-serif, Georgia, Cambria, "Times New Roman", Times, serif !important; }
        body.font-mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace !important; }
        body.font-Inter { font-family: 'Inter', sans-serif !important; }
        body.font-Roboto { font-family: 'Roboto', sans-serif !important; }
        body.font-Open-Sans { font-family: 'Open Sans', sans-serif !important; }
        body.font-Lato { font-family: 'Lato', sans-serif !important; }
        body.font-Montserrat { font-family: 'Montserrat', sans-serif !important; }
        body.font-Merriweather { font-family: 'Merriweather', serif !important; }
    </style>
</head>

<body class="bg-background-dark font-display text-text-light antialiased">

    <div id="unlock-screen" class="flex min-h-screen flex-col items-center justify-center p-4">
        <div class="flex flex-col items-center gap-4 rounded border-2 border-border-light bg-surface p-8 shadow-pixel-container">
            <span class="material-symbols-outlined text-6xl text-primary">shield_lock</span>
            <h1 class="text-lg font-bold uppercase text-primary text-shadow-pixel">Pixel Keep</h1>
            <p class="text-xs text-text-meta">Enter your password to unlock.</p>
            <input type="password" id="password-input" class="pixel-input text-center" placeholder="Your secret key..." />
            <button id="unlock-button" class="pixel-button mt-4 h-14 w-full text-sm uppercase">Unlock</button>
        </div>
    </div>

    <div id="camera-modal" class="fixed inset-0 z-30 flex hidden items-center justify-center bg-background-dark/80">
        <div class="flex flex-col items-center gap-4 rounded border-2 border-border-light bg-surface p-8 shadow-pixel-container">
            <video id="camera-stream" class="w-full" autoplay></video>
            <button id="capture-image-button" class="pixel-button mt-4 h-14 w-full text-sm uppercase">Capture</button>
            <button id="cancel-camera-button" class="pixel-button-secondary mt-2 h-14 w-full text-sm uppercase">Cancel</button>
        </div>
    </div>

    <div id="app-container" class="relative flex min-h-screen w-full flex-col" style="display: none;">

        <header id="app-header" class="sticky top-0 z-10 flex items-center justify-between border-b-4 border-border-dark bg-surface p-4 pb-3 shadow-pixel-container">
            <div class="flex size-10 shrink-0 items-center justify-center text-secondary">
                <span class="material-symbols-outlined text-4xl" id="header-icon">shield_lock</span>
            </div>
            <h1 class="flex-1 text-center text-sm font-bold uppercase tracking-wider text-primary text-shadow-pixel" id="header-title">Pixel Keep</h1>
            <div class="flex items-center justify-end gap-2">
                <button id="export-selected-button" class="pixel-button-surface hidden"><span class="material-symbols-outlined">download_for_offline</span></button>
                <button id="delete-selected-button" class="pixel-button-surface hidden bg-danger"><span class="material-symbols-outlined">delete</span></button>
                <button id="export-button" class="pixel-button-surface"><span class="material-symbols-outlined">file_download</span></button>
                <button id="import-button" class="pixel-button-surface"><span class="material-symbols-outlined">file_upload</span></button>
                <button id="settings-button" class="pixel-button-surface"><span class="material-symbols-outlined">settings</span></button>
                <input type="file" id="import-file-input" class="hidden" accept=".json">
            </div>
        </header>

        <main class="flex-grow pb-24">

            <div id="page-notes-list" class="page p-4">
                <div class="relative py-3">
                    <div class="absolute left-4 top-1/2 -translate-y-1/2 text-primary">
                        <span class="material-symbols-outlined text-xl">search</span>
                    </div>
                    <input id="notes-search-input" class="pixel-input pl-12" placeholder="Search tags, titles, content..." />
                </div>

                <div id="notes-list-container" class="flex flex-col gap-4 pt-2">
                    </div>
                
                <div id="notes-empty-state" class="mt-8 flex hidden flex-col items-center justify-center gap-4 border-2 border-dashed border-border-light/50 bg-surface/50 p-6 text-center">
                    <span class="material-symbols-outlined text-6xl text-primary/70">inventory_2</span>
                    <h3 class="text-sm font-bold text-text-light">Your scroll case is empty.</h3>
                    <p class="max-w-xs text-xs leading-relaxed text-text-light/70">Tap the 'New Note' button to scribe a new scroll!</p>
                </div>

                <div class="fixed bottom-24 right-6 z-20 flex flex-col gap-4">
                    <button id="notes-add-new-folder-button" class="pixel-button-secondary size-14">
                        <span class="material-symbols-outlined text-4xl">create_new_folder</span>
                    </button>
                    <button id="notes-add-new-button" class="pixel-button size-14">
                        <span class="material-symbols-outlined text-4xl">add</span>
                    </button>
                </div>
            </div>

            <div id="page-note-details" class="page hidden p-4">
                <p class="pb-4 pt-1 text-xs font-normal leading-normal text-text-meta" id="note-detail-meta">Last edited: ...</p>
                <div class="flex items-center justify-between">
                    <h2 class="mb-4 text-lg font-bold text-primary" id="note-detail-title">Note Title</h2>
                    <button id="note-detail-copy-btn" class="pixel-button-surface"><span class="material-symbols-outlined">content_copy</span></button>
                </div>
                <div id="note-detail-audio-container" class="hidden mb-4 border-2 border-border-light bg-surface p-2 shadow-pixel-btn">
                    <p class="text-xs text-text-meta mb-1 uppercase">Audio Note</p>
                    <audio id="note-detail-audio" controls class="w-full"></audio>
                </div>

                <div class="note-content-display mb-6 text-xs font-normal leading-relaxed text-text-light/90" id="note-detail-content">
                    Note content...
                </div>
                <div class="flex flex-wrap gap-2" id="note-detail-tags">
                    </div>
            </div>

            <div id="page-note-edit" class="page hidden p-4">
                <form id="note-edit-form" class="flex flex-col gap-4">
                    <input type="hidden" id="note-edit-id" value="">
                    
                    <label class="flex flex-col">
                        <span class="pb-2 text-xs uppercase text-primary">Title</span>
                        <input id="note-edit-title" class="pixel-input" placeholder="Enter Title..." value="" required/>
                    </label>

                    <div class="flex gap-2 overflow-x-auto pb-2">
                        <button type="button" id="note-add-image-gallery" class="pixel-button-surface flex-1 min-w-[60px]" title="Add Image">
                            <span class="material-symbols-outlined">image</span>
                        </button>
                        <button type="button" id="note-add-image-camera" class="pixel-button-surface flex-1 min-w-[60px]" title="Camera">
                            <span class="material-symbols-outlined">photo_camera</span>
                        </button>
                        <button type="button" id="note-record-audio" class="pixel-button-surface flex-1 min-w-[60px]" title="Record Audio">
                            <span class="material-symbols-outlined" id="record-icon">mic</span>
                        </button>
                    </div>

                    <div id="note-edit-audio-wrapper" class="hidden flex flex-col gap-2 border-2 border-border-light bg-surface p-2 shadow-pixel-btn">
                         <div class="flex justify-between items-center">
                            <span class="text-xs text-text-meta uppercase">Audio Recording</span>
                            <button type="button" id="note-delete-audio" class="text-danger text-xs uppercase hover:underline">Remove</button>
                         </div>
                         <audio id="note-edit-audio" controls class="w-full"></audio>
                    </div>
                    
                    <label class="flex flex-col">
                         <span class="pb-2 text-xs uppercase text-primary">Content</span>
                        <div class="flex items-center gap-2 border-2 border-border-light bg-surface p-2 shadow-pixel-btn overflow-x-auto">
                            <button type="button" id="format-bold" class="pixel-button-surface shrink-0"><span class="material-symbols-outlined">format_bold</span></button>
                            <button type="button" id="format-italic" class="pixel-button-surface shrink-0"><span class="material-symbols-outlined">format_italic</span></button>
                            <button type="button" id="format-underline" class="pixel-button-surface shrink-0"><span class="material-symbols-outlined">format_underlined</span></button>
                            <button type="button" id="format-list" class="pixel-button-surface shrink-0"><span class="material-symbols-outlined">format_list_bulleted</span></button>
                        </div>
                        <div id="note-edit-content" class="pixel-textarea min-h-[40vh]" contenteditable="true" placeholder="Your secure note starts here..."></div>
                    </label>
                    
                    <label class="flex flex-col">
                         <span class="pb-2 text-xs uppercase text-primary">Tags (comma separated)</span>
                        <input id="note-edit-tags" class="pixel-input" placeholder="gamedev, ideas, etc..." value=""/>
                    </label>

                    <div class="flex flex-col gap-4 pt-4">
                        <button type="submit" class="pixel-button h-14 text-sm uppercase">Save Scroll</button>
                        <button type="button" id="note-edit-cancel" class="pixel-button-secondary h-14 text-sm uppercase">Cancel</button>
                         <button type="button" id="note-edit-delete" class="pixel-button h-14 bg-danger text-text-light text-sm uppercase hidden">Delete Scroll</button>
                    </div>
                </form>
            </div>

            <div id="page-todos-list" class="page hidden p-4">
                <div id="todos-list-container" class="flex flex-col gap-4 pt-2">
                    </div>

                <div id="todos-empty-state" class="mt-8 flex hidden flex-col items-center justify-center gap-4 border-2 border-dashed border-border-light/50 bg-surface/50 p-6 text-center">
                    <span class="material-symbols-outlined text-6xl text-primary/70">fact_check</span>
                    <h3 class="text-sm font-bold text-text-light">Your quest log is empty.</h3>
                    <p class="max-w-xs text-xs leading-relaxed text-text-light/70">Tap the 'New Quest' button to add a new task!</p>
                </div>
                
                <div class="fixed bottom-24 right-6 z-20 flex flex-col gap-4">
                    <button id="todos-add-new-folder-button" class="pixel-button-secondary size-14">
                        <span class="material-symbols-outlined text-4xl">create_new_folder</span>
                    </button>
                    <button id="todos-add-new-button" class="pixel-button size-14">
                        <span class="material-symbols-outlined text-4xl">add</span>
                    </button>
                </div>
            </div>
            
            <div id="page-task-edit" class="page hidden p-4">
                <form id="task-edit-form" class="flex flex-col gap-4">
                    <input type="hidden" id="task-edit-id" value="">
                    
                    <label class="flex flex-col w-full">
                        <p class="text-xs font-medium uppercase leading-normal pb-2 text-primary">Task</p>
                        <input id="task-edit-title" class="pixel-input" placeholder="What needs to be done?" value="" required/>
                    </label>
                    
                    <label class="flex flex-col w-full">
                        <p class="text-xs font-medium uppercase leading-normal pb-2 text-primary">Time</p>
                        <div class="flex w-full flex-1 items-stretch">
                            <input id="task-edit-time" type="datetime-local" class="pixel-input [color-scheme:dark]" placeholder="Select date & time" value=""/>
                        </div>
                    </label>

                    <label class="flex flex-col w-full">
                        <p class="text-xs font-medium uppercase leading-normal pb-2 text-primary">Location</p>
                        <input id="task-edit-location" class="pixel-input" placeholder="Add a location" value=""/>
                    </label>

                    <label class="flex flex-col w-full">
                        <p class="text-xs font-medium uppercase leading-normal pb-2 text-primary">People</p>
                        <input id="task-edit-people" class="pixel-input" placeholder="Add people" value=""/>
                    </label>

                    <label class="flex flex-col w-full">
                        <p class="text-xs font-medium uppercase leading-normal pb-2 text-primary">Notes</p>
                        <textarea id="task-edit-notes" class="pixel-textarea h-32" placeholder="Add extra details here..."></textarea>
                    </label>
                    
                    <div class="flex flex-col gap-4 pt-4">
                         <button type="submit" class="pixel-button h-14 text-sm uppercase">Save Quest</button>
                         <button type="button" id="task-edit-cancel" class="pixel-button-secondary h-14 text-sm uppercase">Cancel</button>
                         <button type="button" id="task-edit-delete" class="pixel-button h-14 bg-danger text-text-light text-sm uppercase hidden">Delete Quest</button>
                    </div>
                </form>
            </div>

            <div id="page-settings" class="page hidden p-4">
                <div class="mb-6 border-2 border-border-light bg-surface p-4 shadow-pixel-container">
                    <h3 class="mb-4 text-xs uppercase text-primary font-bold">Appearance</h3>
                    
                    <div class="mb-3 flex items-center justify-between">
                        <span class="text-xs text-text-light">Font</span>
                        <select id="setting-font" class="pixel-input !h-8 !w-40 !text-xs">
                            <option value="font-display">Pixel (Default)</option>
                            <option value="font-sans">System Sans</option>
                            <option value="font-serif">System Serif</option>
                            <option value="font-mono">System Mono</option>
                            <optgroup label="Readable Fonts">
                                <option value="Inter">Inter</option>
                                <option value="Roboto">Roboto</option>
                                <option value="Open Sans">Open Sans</option>
                                <option value="Lato">Lato</option>
                                <option value="Montserrat">Montserrat</option>
                                <option value="Merriweather">Merriweather</option>
                            </optgroup>
                        </select>
                    </div>

                    <div class="mb-3 flex items-center justify-between">
                        <span class="text-xs text-text-light">Background</span>
                        <select id="setting-bg" class="pixel-input !h-8 !w-40 !text-xs">
                            <option value="bg-default">Default (Deep Indigo)</option>
                            <option value="bg-solid-black">Solid Black</option>
                            <option value="bg-solid-gray">Solid Gray</option>
                            <option value="bg-midnight">Midnight Blue</option>
                            <option value="bg-forest">Dark Forest</option>
                            <option value="bg-pattern-grid">Pixel Grid</option>
                            <option value="bg-pattern-dots">Polka Dots</option>
                        </select>
                    </div>

                    <div class="mb-3 flex items-center justify-between">
                        <span class="text-xs text-text-light">Text Color</span>
                        <select id="setting-text-color" class="pixel-input !h-8 !w-40 !text-xs">
                            <option value="text-default">Default (Off-White)</option>
                            <option value="text-white">Pure White</option>
                            <option value="text-gray">Comfort Gray</option>
                            <option value="text-terminal-green">Terminal Green</option>
                            <option value="text-terminal-amber">Terminal Amber</option>
                        </select>
                    </div>

                    <div class="mb-3 flex items-center justify-between">
                        <span class="text-xs text-text-light">Line Spacing</span>
                        <select id="setting-line-height" class="pixel-input !h-8 !w-40 !text-xs">
                            <option value="leading-normal">Normal</option>
                            <option value="leading-relaxed">Relaxed</option>
                            <option value="leading-loose">Loose</option>
                        </select>
                    </div>
                    
                    <div class="mb-3 flex items-center justify-between">
                        <span class="text-xs text-text-light">Compact Mode</span>
                         <input type="checkbox" id="setting-compact" class="pixel-checkbox size-5">
                    </div>

                    <div class="flex flex-col gap-2 mt-4">
                         <div class="flex justify-between">
                            <span class="text-xs text-text-light">Interface Scale</span>
                            <span id="setting-scale-value" class="text-xs text-primary">100%</span>
                         </div>
                         <input type="range" id="setting-scale" min="75" max="125" step="5" value="100" class="w-full accent-primary">
                    </div>
                </div>

                 <div class="mb-6 border-2 border-border-light bg-surface p-4 shadow-pixel-container">
                    <h3 class="mb-4 text-xs uppercase text-primary font-bold">About</h3>
                    <p class="text-xs text-text-light/70 leading-relaxed">
                        Pixel Keep v2.0<br>
                        Secure, Offline-First PWA.<br>
                        All data is encrypted locally.
                    </p>
                </div>
            </div>

        </main>

        <nav class="sticky bottom-0 z-10 flex h-20 items-center justify-around border-t-4 border-border-dark bg-surface shadow-pixel-container">
            <button class="nav-button flex flex-col items-center justify-center gap-1 p-2 text-primary" data-page="notes-list">
                <span class="material-symbols-outlined text-3xl">shield_lock</span>
                <span class="text-[10px] font-medium uppercase">Pixel Keep</span>
            </button>
            <button class="nav-button flex flex-col items-center justify-center gap-1 p-2 text-text-light/70" data-page="todos-list">
                <span class="material-symbols-outlined text-3xl">task_alt</span>
                <span class="text-[10px] font-medium uppercase">Quest Log</span>
            </button>
        </nav>

    </div>

    <script src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"></script>
    <script src="crypto-js.min.js"></script>

    <script type="module">
        const { openDB } = idb;

        // --- State ---
        let db;
        let password = '';
        let isAuthenticated = false;
        let currentImageClickHandler = null;
        let currentNotesFolder = "root_notes";
        let currentTasksFolder = "root_tasks";
        let currentSearchQuery = ""; // State for search
        
        // Settings State
        let settings = {
            font: 'font-display',
            bg: 'bg-default',
            textColor: 'text-default',
            lineHeight: 'leading-normal',
            compact: false,
            scale: 100
        };

        // Audio State
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let currentAudioBase64 = null;

        // --- DOM Elements ---
        const unlockScreen = document.getElementById('unlock-screen');
        const appContainer = document.getElementById('app-container');
        const passwordInput = document.getElementById('password-input');
        const unlockButton = document.getElementById('unlock-button');
        
        const pages = document.querySelectorAll('.page');
        const navButtons = document.querySelectorAll('.nav-button');
        const headerTitle = document.getElementById('header-title');
        const headerIcon = document.getElementById('header-icon');
        
        // Notes List
        const notesListContainer = document.getElementById('notes-list-container');
        const notesEmptyState = document.getElementById('notes-empty-state');
        const notesSearchInput = document.getElementById('notes-search-input');
        
        // Todo List
        const todosListContainer = document.getElementById('todos-list-container');
        const todosEmptyState = document.getElementById('todos-empty-state');
        
        // Note Edit
        const noteEditForm = document.getElementById('note-edit-form');
        const noteEditId = document.getElementById('note-edit-id');
        const noteEditTitle = document.getElementById('note-edit-title');
        const noteEditContent = document.getElementById('note-edit-content');
        const noteEditTags = document.getElementById('note-edit-tags');
        const noteEditCancel = document.getElementById('note-edit-cancel');
        const noteEditDelete = document.getElementById('note-edit-delete');
        
        // Note Audio Edit Elements
        const recordBtn = document.getElementById('note-record-audio');
        const recordIcon = document.getElementById('record-icon');
        const noteEditAudioWrapper = document.getElementById('note-edit-audio-wrapper');
        const noteEditAudioPlayer = document.getElementById('note-edit-audio');
        const noteDeleteAudioBtn = document.getElementById('note-delete-audio');

        // Note Details
        const noteDetailTitle = document.getElementById('note-detail-title');
        const noteDetailMeta = document.getElementById('note-detail-meta');
        const noteDetailContent = document.getElementById('note-detail-content');
        const noteDetailTags = document.getElementById('note-detail-tags');
        const noteDetailAudioContainer = document.getElementById('note-detail-audio-container');
        const noteDetailAudioPlayer = document.getElementById('note-detail-audio');

        // Task Edit
        const taskEditForm = document.getElementById('task-edit-form');
        const taskEditId = document.getElementById('task-edit-id');
        const taskEditTitle = document.getElementById('task-edit-title');
        const taskEditTime = document.getElementById('task-edit-time');
        const taskEditLocation = document.getElementById('task-edit-location');
        const taskEditPeople = document.getElementById('task-edit-people');
        const taskEditNotes = document.getElementById('task-edit-notes');
        const taskEditCancel = document.getElementById('task-edit-cancel');
        const taskEditDelete = document.getElementById('task-edit-delete');

        // --- Encryption ---
        function encrypt(data, key) {
            return CryptoJS.AES.encrypt(JSON.stringify(data), key).toString();
        }

        function decrypt(cipher, key) {
            try {
                const bytes = CryptoJS.AES.decrypt(cipher, key);
                const decrypted = bytes.toString(CryptoJS.enc.Utf8);
                return decrypted ? JSON.parse(decrypted) : null;
            } catch (e) {
                console.error("Decryption failed:", e);
                return null;
            }
        }

        // --- Database Setup ---
        async function initDB() {
            db = await openDB('PixelPWADatabase', 2, {
                upgrade(db) {
                    if (!db.objectStoreNames.contains('notes')) {
                        db.createObjectStore('notes', { keyPath: 'id' });
                    }
                    if (!db.objectStoreNames.contains('tasks')) {
                        db.createObjectStore('tasks', { keyPath: 'id' });
                    }
                    if (!db.objectStoreNames.contains('meta')) {
                        db.createObjectStore('meta', { keyPath: 'key' });
                    }
                    if (!db.objectStoreNames.contains('fs_nodes')) {
                        db.createObjectStore('fs_nodes', { keyPath: 'id' });
                    }
                },
            });
        }

        // --- Authentication ---
        async function handleUnlock() {
            const enteredPassword = passwordInput.value.trim();
            if (!enteredPassword) {
                alert('Please enter a password.');
                return;
            }

            const check = await db.get('meta', 'password_check');
            
            if (check) {
                if (decrypt(check.value, enteredPassword) === 'ok') {
                    password = enteredPassword;
                    isAuthenticated = true;
                    await runMigrationV2();
                    startApp();
                } else {
                    alert('Wrong password.');
                }
            } else {
                const verification = { key: 'password_check', value: encrypt('ok', enteredPassword) };
                await db.put('meta', verification);
                password = enteredPassword;
                isAuthenticated = true;
                await runMigrationV2();
                startApp();
            }
        }

        async function runMigrationV2() {
            const migrationFlag = await db.get('meta', 'migration-v2-complete');
            if (migrationFlag) return;

            console.log("Running migration to v2 folder system...");
            const encryptedNotes = await db.getAll('notes');
            for (const encryptedNote of encryptedNotes) {
                const note = decrypt(encryptedNote.data, password);
                if (note) {
                    const fsNode = {
                        id: `note-${note.id}`,
                        parentId: "root_notes",
                        type: "note",
                        name: note.title,
                        order: note.order || note.id,
                        itemRefId: note.id
                    };
                    const encryptedNode = encrypt(fsNode, password);
                    await db.put('fs_nodes', { id: fsNode.id, data: encryptedNode });
                }
            }

            const encryptedTasks = await db.getAll('tasks');
            for (const encryptedTask of encryptedTasks) {
                const task = decrypt(encryptedTask.data, password);
                if (task) {
                    const fsNode = {
                        id: `task-${task.id}`,
                        parentId: "root_tasks",
                        type: "task",
                        name: task.title,
                        order: task.id,
                        itemRefId: task.id
                    };
                    const encryptedNode = encrypt(fsNode, password);
                    await db.put('fs_nodes', { id: fsNode.id, data: encryptedNode });
                }
            }

            await db.put('meta', { key: 'migration-v2-complete', value: true });
            console.log("Migration complete.");
        }

        function startApp() {
            unlockScreen.style.display = 'none';
            appContainer.style.display = 'flex';
            setupEventListeners();
            setupDragAndDrop();
            setupAudioListeners(); // Initialize Audio
            router();
        }

        function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('/sw.js')
                        .then(registration => console.log('Service Worker registered'))
                        .catch(error => console.error('SW registration failed:', error));
                });
            }
        }
        
        // --- Audio Functions ---
        function setupAudioListeners() {
            recordBtn.addEventListener('click', toggleRecording);
            noteDeleteAudioBtn.addEventListener('click', deleteAudio);
        }

        async function toggleRecording() {
            if (isRecording) {
                stopRecording();
            } else {
                await startRecording();
            }
        }

        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];

                mediaRecorder.ondataavailable = (e) => {
                    audioChunks.push(e.data);
                };

                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        currentAudioBase64 = reader.result;
                        updateAudioUI(currentAudioBase64);
                    };
                    reader.readAsDataURL(audioBlob);
                    
                    stream.getTracks().forEach(track => track.stop());
                };

                mediaRecorder.start();
                isRecording = true;
                recordBtn.classList.add('recording-pulse', 'bg-danger', 'border-danger');
                recordIcon.textContent = 'stop_circle';
            } catch (err) {
                console.error("Error accessing microphone:", err);
                alert("Could not access microphone. Please check permissions.");
            }
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                recordBtn.classList.remove('recording-pulse', 'bg-danger', 'border-danger');
                recordIcon.textContent = 'mic';
            }
        }

        function updateAudioUI(base64Audio) {
            if (base64Audio) {
                noteEditAudioWrapper.classList.remove('hidden');
                noteEditAudioPlayer.src = base64Audio;
            } else {
                noteEditAudioWrapper.classList.add('hidden');
                noteEditAudioPlayer.src = '';
            }
        }

        function deleteAudio() {
            if(confirm("Remove audio recording?")) {
                currentAudioBase64 = null;
                updateAudioUI(null);
            }
        }

        // --- Router ---
        function router() {
            if (!isAuthenticated) return;

            removeImageSelection();

            const hash = location.hash || '#page-notes-list';
            let currentPageId = 'page-notes-list';
            
            pages.forEach(page => page.classList.add('hidden'));

            const editor = document.getElementById('note-edit-content');
            if (currentImageClickHandler) {
                editor.removeEventListener('click', currentImageClickHandler);
                currentImageClickHandler = null;
            }

            if (hash.startsWith('#page-note-edit')) {
                currentPageId = 'page-note-edit';
                const id = hash.split('/')[1];
                showNoteEditor(id);
                currentImageClickHandler = (e) => {
                    if (e.target.tagName === 'IMG') {
                        makeImageEditable(e.target);
                    } else {
                        removeImageSelection();
                    }
                };
                editor.addEventListener('click', currentImageClickHandler);
            } else if (hash.startsWith('#page-note-details')) {
                currentPageId = 'page-note-details';
                const id = hash.split('/')[1];
                showNoteDetails(id);
            } else if (hash.startsWith('#page-task-edit')) {
                currentPageId = 'page-task-edit';
                const id = hash.split('/')[1];
                showTaskEditor(id);
            } else if (hash.startsWith('#page-todos-list')) {
                currentPageId = 'page-todos-list';
                const folderId = hash.split('/')[1] || 'root_tasks';
                currentTasksFolder = folderId;
                renderTasksList();
            } else if (hash.startsWith('#page-notes-list')) {
                currentPageId = 'page-notes-list';
                const folderId = hash.split('/')[1] || 'root_notes';
                currentNotesFolder = folderId;
                // Reset search when navigating folders if desired, or keep it. 
                // For now, we keep state but could clear: currentSearchQuery = ""; notesSearchInput.value = "";
                renderNotesList();
            } else if (hash.startsWith('#page-settings')) {
                currentPageId = 'page-settings';
                initSettingsUI();
            } else {
                currentPageId = 'page-notes-list';
                currentNotesFolder = 'root_notes';
                renderNotesList();
            }

            const currentPage = document.getElementById(currentPageId);
            if (currentPage) {
                currentPage.classList.remove('hidden');
            }
            updateUI(currentPageId);
        }

        function updateUI(pageId) {
            navButtons.forEach(btn => {
                if (pageId.includes(btn.dataset.page)) {
                    btn.classList.add('text-primary');
                    btn.classList.remove('text-text-light/70');
                } else {
                    btn.classList.remove('text-primary');
                    btn.classList.add('text-text-light/70');
                }
            });

            const fabNotes = document.getElementById('notes-add-new-button');
            const fabTodos = document.getElementById('todos-add-new-button');
            const fabNewFolderNotes = document.getElementById('notes-add-new-folder-button');
            const fabNewFolderTodos = document.getElementById('todos-add-new-folder-button');
            const exportSelectedBtn = document.getElementById('export-selected-button');
            const deleteSelectedBtn = document.getElementById('delete-selected-button');
            
            fabNotes.classList.add('hidden');
            fabTodos.classList.add('hidden');
            fabNewFolderNotes.classList.add('hidden');
            fabNewFolderTodos.classList.add('hidden');
            exportSelectedBtn.classList.add('hidden');
            deleteSelectedBtn.classList.add('hidden');

            if (pageId.includes('notes-list')) {
                headerTitle.textContent = 'Pixel Keep';
                headerIcon.textContent = 'shield_lock';
                fabNotes.classList.remove('hidden');
                fabNewFolderNotes.classList.remove('hidden');

                const selectedItems = document.querySelectorAll('.note-select-checkbox:checked, .folder-select-checkbox:checked');
                if (selectedItems.length > 0) {
                    exportSelectedBtn.classList.remove('hidden');
                    deleteSelectedBtn.classList.remove('hidden');
                }

            } else if (pageId.includes('todos-list')) {
                headerTitle.textContent = 'Quest Log';
                headerIcon.textContent = 'task_alt';
                fabTodos.classList.remove('hidden');
                fabNewFolderTodos.classList.remove('hidden');
            } else if (pageId === 'page-note-edit') {
                headerTitle.textContent = noteEditId.value ? 'Edit Scroll' : 'New Scroll';
                headerIcon.textContent = 'edit';
            } else if (pageId === 'page-note-details') {
                headerTitle.textContent = 'View Scroll';
                headerIcon.textContent = 'visibility';
            } else if (pageId === 'page-task-edit') {
                headerTitle.textContent = taskEditId.value ? 'Edit Quest' : 'New Quest';
                headerIcon.textContent = 'edit_note';
            } else if (pageId === 'page-settings') {
                headerTitle.textContent = 'Settings';
                headerIcon.textContent = 'settings';
            }
        }

        // --- Notes CRUD & Rendering ---

        function stripHTML(html) {
            const doc = new DOMParser().parseFromString(html, 'text/html');
            return doc.body.textContent || "";
        }

        async function renderNotesList() {
            const encryptedNodes = await db.getAll('fs_nodes');
            const allNodes = encryptedNodes
                .map(n => decrypt(n.data, password))
                .filter(Boolean);

            const items = allNodes
                .filter(n => n.parentId === currentNotesFolder && n.type === 'note')
                .sort((a, b) => (a.order || 0) - (b.order || 0));

            const folders = allNodes
                .filter(n => n.parentId === currentNotesFolder && n.type === 'folder')
                .sort((a, b) => (a.order || 0) - (b.order || 0));

            notesListContainer.innerHTML = '';

            // 1. Decrypt actual notes to filter them
            let notesToDisplay = [];
            
            // Helper to process note filtering
            const searchLower = currentSearchQuery.toLowerCase().trim();

            for (const noteNode of items) {
                const encryptedNote = await getNoteById(noteNode.itemRefId);
                if (!encryptedNote) continue;

                const note = decrypt(encryptedNote.data, password);
                if (!note) continue;

                // Filter Logic
                if (searchLower) {
                    const titleMatch = (note.title || '').toLowerCase().includes(searchLower);
                    const contentMatch = stripHTML(note.content || '').toLowerCase().includes(searchLower);
                    const tagMatch = (note.tags || []).some(tag => tag.toLowerCase().includes(searchLower));
                    
                    if (!titleMatch && !contentMatch && !tagMatch) {
                        continue; 
                    }
                }

                notesToDisplay.push({ node: noteNode, data: note });
            }
            
            // Filter folders? Currently only filtering notes content. 
            // If search is active, we might hide folders or filter them by name.
            // For simplicity, if search is active, we hide folders to show flat results, or just filter by name.
            let foldersToDisplay = folders;
            if (searchLower) {
                foldersToDisplay = folders.filter(f => f.name.toLowerCase().includes(searchLower));
            }

            if (notesToDisplay.length === 0 && foldersToDisplay.length === 0) {
                notesEmptyState.classList.remove('hidden');
                return;
            }
            notesEmptyState.classList.add('hidden');

            // Render Folders
            foldersToDisplay.forEach(folder => {
                const folderEl = document.createElement('div');
                folderEl.className = 'flex items-center justify-between gap-3 border-2 border-border-light bg-surface p-3 shadow-pixel-container';
                folderEl.setAttribute('draggable', 'true');
                folderEl.dataset.id = folder.id;
                folderEl.dataset.type = 'folder';
                
                folderEl.innerHTML = `
                    <div class="flex items-center gap-3 cursor-pointer flex-grow" data-folder-id="${folder.id}">
                        <input type="checkbox" class="pixel-checkbox folder-select-checkbox" data-id="${folder.id}">
                        <span class="material-symbols-outlined text-4xl text-secondary">folder</span>
                        <p class="text-sm font-bold leading-tight text-primary truncate">${folder.name || 'Untitled Folder'}</p>
                    </div>
                    <button class="pixel-button-surface folder-delete-btn" data-id="${folder.id}"><span class="material-symbols-outlined">delete</span></button>
                `;
                folderEl.querySelector('[data-folder-id]').addEventListener('click', (e) => {
                    if (e.target.type === 'checkbox') return;
                    // Clear search when entering a folder? Maybe better UX.
                    notesSearchInput.value = "";
                    currentSearchQuery = "";
                    location.hash = `#page-notes-list/${folder.id}`;
                });
                notesListContainer.appendChild(folderEl);
            });

            // Render Notes
            for (const { node: noteNode, data: note } of notesToDisplay) {
                const noteEl = document.createElement('div');
                noteEl.className = 'flex flex-col gap-3 border-2 border-border-light bg-surface p-3 shadow-pixel-container';
                noteEl.setAttribute('draggable', 'true');
                noteEl.dataset.id = noteNode.id;
                noteEl.dataset.type = 'note';
                
                const plainContent = stripHTML(note.content);
                const contentPreview = plainContent || 'No content...';
                
                // Tag HTML generation - make them clickable
                const tagsHtml = (note.tags || []).map(tag => 
                    `<span class="tag-chip material-symbols-outlined text-secondary text-sm hover:text-primary transition-colors" title="Filter by ${tag}" data-tag="${tag}">label</span>`
                ).join('');

                // Audio Icon
                const audioIcon = note.audio ? `<span class="material-symbols-outlined text-warning" title="Has Audio">mic</span>` : '';

                noteEl.innerHTML = `
                    <div class="flex items-start justify-between">
                        <div class="flex items-center gap-3 w-full">
                            <input type="checkbox" class="pixel-checkbox note-select-checkbox" data-id="${noteNode.itemRefId}">
                            <div class="flex flex-col justify-center min-w-0 w-full">
                                <div class="flex items-center gap-2">
                                     <p class="text-xs font-bold leading-tight text-primary truncate">${note.title || 'Untitled'}</p>
                                     ${audioIcon}
                                </div>
                                <p class="mt-2 text-[10px] font-normal leading-snug text-text-light/80 break-words note-preview-content">${contentPreview}</p>
                            </div>
                        </div>
                        <div class="ml-2 flex shrink-0 items-center gap-1 flex-wrap max-w-[60px] justify-end">
                           ${tagsHtml}
                        </div>
                    </div>
                    <div class="flex items-center justify-end gap-2 border-t-2 border-dashed border-border-light pt-2">
                        <button class="pixel-button-surface note-copy-btn" data-id="${noteNode.itemRefId}"><span class="material-symbols-outlined">content_copy</span></button>
                        <button class="pixel-button-surface note-view-btn" data-id="${noteNode.itemRefId}"><span class="material-symbols-outlined">visibility</span></button>
                        <button class="pixel-button-surface note-edit-btn" data-id="${noteNode.itemRefId}"><span class="material-symbols-outlined">edit</span></button>
                        <button class="pixel-button-surface note-delete-btn" data-id="${noteNode.id}"><span class="material-symbols-outlined">delete</span></button>
                    </div>
                `;
                
                // Add Tag Click Listeners
                noteEl.querySelectorAll('.tag-chip').forEach(chip => {
                    chip.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const tag = e.target.dataset.tag;
                        notesSearchInput.value = tag;
                        currentSearchQuery = tag;
                        renderNotesList();
                    });
                });

                notesListContainer.appendChild(noteEl);
            }
        }

        async function getNoteById(id) {
            let encryptedNote = await db.get('notes', Number(id));
            if (!encryptedNote) {
                encryptedNote = await db.get('notes', id);
            }
            return encryptedNote;
        }

        async function showNoteDetails(id) {
            const encryptedNote = await getNoteById(id);
            if (!encryptedNote) {
                location.hash = '#page-notes-list';
                return;
            }
            const note = decrypt(encryptedNote.data, password);

            noteDetailTitle.textContent = note.title;
            noteDetailContent.innerHTML = note.content; 
            noteDetailMeta.textContent = `Last edited: ${new Date(note.updatedAt).toLocaleString()}`;
            
            const copyBtn = document.getElementById('note-detail-copy-btn');
            copyBtn.dataset.id = id;

            // Audio in Details
            if (note.audio) {
                noteDetailAudioContainer.classList.remove('hidden');
                noteDetailAudioPlayer.src = note.audio;
            } else {
                noteDetailAudioContainer.classList.add('hidden');
                noteDetailAudioPlayer.src = "";
            }

            noteDetailTags.innerHTML = '';
            (note.tags || []).forEach(tag => {
                noteDetailTags.innerHTML += `<span class="border-2 border-border-light bg-surface px-3 py-1 text-[10px] font-medium text-primary shadow-pixel-btn">#${tag}</span>`;
            });
        }
        
        function removeImageSelection() {
            const currentlySelected = document.querySelector('.selected-image');
            if (currentlySelected) {
                currentlySelected.classList.remove('selected-image');
                const existingHandle = currentlySelected.parentElement.querySelector('.resize-handle');
                if (existingHandle) {
                    existingHandle.remove();
                }
            }
        }

        function makeImageEditable(img) {
            removeImageSelection();

            img.classList.add('selected-image');

            const wrapper = document.createElement('div');
            wrapper.style.position = 'relative';
            wrapper.style.display = 'inline-block';
            img.parentNode.insertBefore(wrapper, img);
            wrapper.appendChild(img);

            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'resize-handle resize-handle-br';
            wrapper.appendChild(resizeHandle);

            let startX, startY, startWidth, startHeight;

            function startDrag(e) {
                e.preventDefault();
                startX = e.clientX || e.touches[0].clientX;
                startY = e.clientY || e.touches[0].clientY;
                startWidth = parseInt(document.defaultView.getComputedStyle(img).width, 10);
                startHeight = parseInt(document.defaultView.getComputedStyle(img).height, 10);
                document.documentElement.addEventListener('mousemove', doDrag, false);
                document.documentElement.addEventListener('touchmove', doDrag, false);
                document.documentElement.addEventListener('mouseup', stopDrag, false);
                document.documentElement.addEventListener('touchend', stopDrag, false);
            }

            function doDrag(e) {
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                img.style.width = (startWidth + clientX - startX) + 'px';
                img.style.height = (startHeight + clientY - startY) + 'px';
            }

            function stopDrag() {
                document.documentElement.removeEventListener('mousemove', doDrag, false);
                document.documentElement.removeEventListener('touchmove', doDrag, false);
                document.documentElement.removeEventListener('mouseup', stopDrag, false);
                document.documentElement.removeEventListener('touchend', stopDrag, false);
            }

            resizeHandle.addEventListener('mousedown', startDrag, false);
            resizeHandle.addEventListener('touchstart', startDrag, false);
        }

        async function showNoteEditor(id) {
            if (id) {
                const encryptedNote = await getNoteById(id);
                if (encryptedNote) {
                    const note = decrypt(encryptedNote.data, password);
                    noteEditId.value = note.id;
                    noteEditTitle.value = note.title;
                    noteEditContent.innerHTML = note.content;
                    noteEditTags.value = (note.tags || []).join(', ');
                    
                    // Load Audio
                    currentAudioBase64 = note.audio || null;
                    updateAudioUI(currentAudioBase64);

                    noteEditDelete.classList.remove('hidden');
                }
            } else {
                noteEditForm.reset();
                noteEditId.value = '';
                noteEditContent.innerHTML = '';
                currentAudioBase64 = null;
                updateAudioUI(null);
                noteEditDelete.classList.add('hidden');
            }
            noteEditContent.focus();
            updateFormatButtons();

            let draggedImage = null;

            const editor = document.getElementById('note-edit-content');
            editor.addEventListener('dragstart', (e) => {
                if (e.target.tagName === 'IMG') {
                    draggedImage = e.target;
                }
            });

            editor.addEventListener('dragover', (e) => {
                e.preventDefault();
            });

            editor.addEventListener('drop', (e) => {
                e.preventDefault();
                if (draggedImage) {
                    const range = document.caretRangeFromPoint(e.clientX, e.clientY);
                    if (range) {
                        range.insertNode(draggedImage);
                    }
                }
                draggedImage = null;
            });
        }

        async function saveNote(e) {
            e.preventDefault();
            const isNewNote = !noteEditId.value;
            const id = isNewNote ? Date.now() : Number(noteEditId.value);
            const tags = noteEditTags.value.split(',').map(t => t.trim()).filter(t => t.length > 0);

            let order;
            if (isNewNote) {
                const encryptedNodes = await db.getAll('fs_nodes');
                const allNodes = encryptedNodes
                    .map(n => decrypt(n.data, password))
                    .filter(Boolean);
                const folderNodes = allNodes.filter(n => n.parentId === currentNotesFolder);
                const minOrder = Math.min(0, ...folderNodes.map(n => n.order || 0));
                order = minOrder - 1;
            } else {
                const encryptedNote = await getNoteById(id);
                const noteData = decrypt(encryptedNote.data, password);
                order = noteData.order || id;
            }

            const note = {
                id: id,
                title: noteEditTitle.value,
                content: noteEditContent.innerHTML,
                tags: tags,
                audio: currentAudioBase64, // Save audio
                updatedAt: new Date().toISOString(),
                order: order
            };

            const encryptedData = encrypt(note, password);
            await db.put('notes', { id: id, data: encryptedData });

            if (isNewNote) {
                const fsNode = {
                    id: `note-${id}`,
                    parentId: currentNotesFolder,
                    type: "note",
                    name: note.title,
                    order: note.order,
                    itemRefId: id
                };
                const encryptedNode = encrypt(fsNode, password);
                await db.put('fs_nodes', { id: fsNode.id, data: encryptedNode });
            } else {
                const nodeId = `note-${id}`;
                const encryptedNode = await db.get('fs_nodes', nodeId);
                if (encryptedNode) {
                    const nodeToUpdate = decrypt(encryptedNode.data, password);
                    if (nodeToUpdate.name !== note.title) {
                        nodeToUpdate.name = note.title;
                        const encryptedUpdatedNode = encrypt(nodeToUpdate, password);
                        await db.put('fs_nodes', { id: nodeId, data: encryptedUpdatedNode });
                    }
                }
            }
            
            noteEditForm.reset();
            location.hash = `#page-notes-list/${currentNotesFolder}`;
        }

        async function deleteNote(nodeId) {
            const encryptedNode = await db.get('fs_nodes', nodeId);
            if (!encryptedNode) return;

            const node = decrypt(encryptedNode.data, password);
            
            await db.delete('notes', Number(node.itemRefId));
            await db.delete('fs_nodes', nodeId);
        }

        async function deleteFolderRecursive(folderId) {
            const encryptedNodes = await db.getAll('fs_nodes');
            const allNodes = encryptedNodes.map(n => decrypt(n.data, password)).filter(Boolean);
            
            const children = allNodes.filter(n => n.parentId === folderId);

            for (const child of children) {
                if (child.type === 'folder') {
                    await deleteFolderRecursive(child.id);
                } else if (child.type === 'note') {
                    await db.delete('notes', Number(child.itemRefId));
                    await db.delete('fs_nodes', child.id);
                } else if (child.type === 'task') {
                    await db.delete('tasks', Number(child.itemRefId));
                    await db.delete('fs_nodes', child.id);
                }
            }

            await db.delete('fs_nodes', folderId);
        }                        
        
        // --- Tasks CRUD & Rendering ---
        
        async function renderTasksList() {
            const encryptedNodes = await db.getAll('fs_nodes');
            const allNodes = encryptedNodes
                .map(n => decrypt(n.data, password))
                .filter(Boolean);

            const items = allNodes
                .filter(n => n.parentId === currentTasksFolder && n.type === 'task')
                .sort((a, b) => (a.order || 0) - (b.order || 0));

            const folders = allNodes
                .filter(n => n.parentId === currentTasksFolder && n.type === 'folder')
                .sort((a, b) => (a.order || 0) - (b.order || 0));

            todosListContainer.innerHTML = '';

            if (items.length === 0 && folders.length === 0) {
                todosEmptyState.classList.remove('hidden');
                return;
            }
            todosEmptyState.classList.add('hidden');

            // Render Folders
            folders.forEach(folder => {
                const folderEl = document.createElement('div');
                folderEl.className = 'flex items-center justify-between gap-3 border-2 border-border-light bg-surface p-3 shadow-pixel-container';
                folderEl.setAttribute('draggable', 'true');
                folderEl.dataset.id = folder.id;
                folderEl.dataset.type = 'folder';

                folderEl.innerHTML = `
                    <div class="flex items-center gap-3 cursor-pointer flex-grow" data-folder-id="${folder.id}">
                        <input type="checkbox" class="pixel-checkbox folder-select-checkbox" data-id="${folder.id}">
                        <span class="material-symbols-outlined text-4xl text-secondary">folder</span>
                        <p class="text-sm font-bold leading-tight text-primary truncate">${folder.name || 'Untitled Folder'}</p>
                    </div>
                    <button class="pixel-button-surface folder-delete-btn" data-id="${folder.id}"><span class="material-symbols-outlined">delete</span></button>
                `;
                folderEl.querySelector('[data-folder-id]').addEventListener('click', (e) => {
                    if (e.target.type === 'checkbox') return;
                    location.hash = `#page-todos-list/${folder.id}`;
                });
                todosListContainer.appendChild(folderEl);
            });                        
            
            // Render Tasks
            for (const taskNode of items) {
                const encryptedTask = await db.get('tasks', Number(taskNode.itemRefId));
                if (!encryptedTask) continue;

                const task = decrypt(encryptedTask.data, password);
                if (!task) continue;

                const taskEl = document.createElement('div');
                const completed = task.completed || false;
                taskEl.className = `flex flex-wrap items-start gap-4 border-2 border-border-light bg-surface p-3 shadow-pixel-container ${completed ? 'opacity-50' : ''}`;
                taskEl.dataset.id = taskNode.id; 
                taskEl.setAttribute('draggable', 'true');
                taskEl.dataset.type = 'task';
                
                const timeStr = task.time ? new Date(task.time).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '';
                const dateStr = task.time ? new Date(task.time).toLocaleDateString() : ''; 
                
                taskEl.innerHTML = `
                    <div class="flex items-start justify-between w-full">
                        <div class="flex pt-1">
                            <input type="checkbox" class="pixel-checkbox task-toggle-btn" data-id="${task.id}" ${completed ? 'checked' : ''}>
                        </div>
                        <div class="flex flex-1 flex-col justify-center gap-2 min-w-0">
                            <p class="text-xs font-bold leading-normal ${completed ? 'text-text-light/70 line-through' : 'text-primary'}">${task.title}</p>
                            <div class="mt-1 space-y-1 text-[10px] text-text-meta">
                                ${dateStr ? `<div class="flex items-center gap-2"><span class="material-symbols-outlined text-base">event</span><p>${dateStr}</p></div>` : ''}
                                ${timeStr ? `<div class="flex items-center gap-2"><span class="material-symbols-outlined text-base">schedule</span><p>${timeStr}</p></div>` : ''}
                                ${task.location ? `<div class="flex items-center gap-2"><span class="material-symbols-outlined text-base">location_on</span><p>${task.location}</p></div>` : ''}
                                ${task.people ? `<div class="flex items-center gap-2"><span class="material-symbols-outlined text-base">group</span><p>${task.people}</p></div>` : ''}
                            </div>
                        </div>
                        <div class="flex items-center">
                            ${task.notes ? `<button class="pixel-button-surface task-notes-toggle-btn"><span class="material-symbols-outlined">expand_more</span></button>` : ''}
                            <button class="pixel-button-surface task-edit-btn" data-id="${taskNode.itemRefId}">
                                <span class="material-symbols-outlined">edit</span>
                            </button>
                            <button class="pixel-button-surface task-delete-btn" data-id="${taskNode.id}">
                                <span class="material-symbols-outlined">delete</span>
                            </button>
                        </div>
                    </div>
                    ${task.notes ? `<div class="task-notes hidden w-full mt-2 pt-2 border-t-2 border-dashed border-border-light text-xs text-text-light/80">${task.notes}</div>` : ''}
                `;
                todosListContainer.appendChild(taskEl);
            }
        }

        async function showTaskEditor(id) {
            if (id) {
                const encryptedTask = await db.get('tasks', Number(id));
                if (encryptedTask) {
                    const task = decrypt(encryptedTask.data, password);
                    taskEditId.value = task.id;
                    taskEditTitle.value = task.title;
                    taskEditTime.value = task.time ? new Date(new Date(task.time).getTime() - (new Date().getTimezoneOffset() * 60000)).toISOString().slice(0, 16) : '';
                    taskEditLocation.value = task.location || '';
                    taskEditPeople.value = task.people || '';
                    taskEditNotes.value = task.notes || '';
                    taskEditDelete.classList.remove('hidden');
                }
            } else {
                taskEditForm.reset();
                taskEditId.value = '';
                taskEditDelete.classList.add('hidden');
            }
        }
        
        async function saveTask(e) {
            e.preventDefault();
            const isNewTask = !taskEditId.value;
            const id = isNewTask ? Date.now() : Number(taskEditId.value);
            
            let completedStatus = false;
            if (!isNewTask) {
                const encryptedOldTask = await db.get('tasks', id);
                if(encryptedOldTask) {
                    const oldTask = decrypt(encryptedOldTask.data, password);
                    completedStatus = oldTask.completed;
                }
            }

            const task = {
                id: id,
                title: taskEditTitle.value,
                time: taskEditTime.value ? new Date(taskEditTime.value).toISOString() : null,
                location: taskEditLocation.value,
                people: taskEditPeople.value,
                notes: taskEditNotes.value,
                completed: completedStatus,
                updatedAt: new Date().toISOString()
            };
            
            const encryptedData = encrypt(task, password);
            await db.put('tasks', { id: id, data: encryptedData });

            if (isNewTask) {
                const fsNode = {
                    id: `task-${id}`,
                    parentId: currentTasksFolder,
                    type: "task",
                    name: task.title,
                    order: id,
                    itemRefId: id
                };
                const encryptedNode = encrypt(fsNode, password);
                await db.put('fs_nodes', { id: fsNode.id, data: encryptedNode });
            } else {
                const nodeId = `task-${id}`;
                const encryptedNode = await db.get('fs_nodes', nodeId);
                if (encryptedNode) {
                    const nodeToUpdate = decrypt(encryptedNode.data, password);
                    if (nodeToUpdate.name !== task.title) {
                        nodeToUpdate.name = task.title;
                        const encryptedUpdatedNode = encrypt(nodeToUpdate, password);
                        await db.put('fs_nodes', { id: nodeId, data: encryptedUpdatedNode });
                    }
                }
            }
            
            taskEditForm.reset();
            location.hash = `#page-todos-list/${currentTasksFolder}`;
        }

        async function deleteTask(nodeId) {
            const encryptedNode = await db.get('fs_nodes', nodeId);
            if (!encryptedNode) return;

            const node = decrypt(encryptedNode.data, password);

            await db.delete('tasks', Number(node.itemRefId));
            await db.delete('fs_nodes', nodeId);
        }                        
        
        async function toggleTask(id) {
             const encryptedTask = await db.get('tasks', Number(id));
             if (encryptedTask) {
                 const task = decrypt(encryptedTask.data, password);
                 task.completed = !task.completed;
                 const encryptedData = encrypt(task, password);
                 await db.put('tasks', { id: task.id, data: encryptedData });
                 renderTasksList();
             }
        }

        // --- Image Handling ---
        function addImageFromGallery() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = e => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = readerEvent => {
                    const content = readerEvent.target.result;
                    const editor = document.getElementById('note-edit-content');
                    const imgTag = `<img src="${content}" class="w-full">`;
                    editor.focus();
                    document.execCommand('insertHTML', false, imgTag);
                }
                reader.readAsDataURL(file);
            }
            input.click();
        }

        async function openCamera() {
            const cameraModal = document.getElementById('camera-modal');
            const video = document.getElementById('camera-stream');
            cameraModal.classList.remove('hidden');

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
            } catch (err) {
                console.error("Error accessing camera: ", err);
                cameraModal.classList.add('hidden');
            }
        }

        function captureImage() {
            const cameraModal = document.getElementById('camera-modal');
            const video = document.getElementById('camera-stream');
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const context = canvas.getContext('2d');
            context.drawImage(video, 0, 0, canvas.width, canvas.height);
            const dataUrl = canvas.toDataURL('image/png');
            
            const editor = document.getElementById('note-edit-content');
            const imgTag = `<img src="${dataUrl}" class="w-full">`;
            editor.focus();
            document.execCommand('insertHTML', false, imgTag);

            // Stop the stream and hide the modal
            const stream = video.srcObject;
            const tracks = stream.getTracks();
            tracks.forEach(track => track.stop());
            cameraModal.classList.add('hidden');
        }

        function closeCamera() {
            const cameraModal = document.getElementById('camera-modal');
            const video = document.getElementById('camera-stream');
            const stream = video.srcObject;
            if (stream) {
                const tracks = stream.getTracks();
                tracks.forEach(track => track.stop());
            }
            cameraModal.classList.add('hidden');
        }

        function formatText(command) {
            const editor = document.getElementById('note-edit-content');
            editor.focus(); // Ensure the editor is focused

            if (command === 'bold') {
                document.execCommand('bold', false, null);
            } else if (command === 'italic') {
                document.execCommand('italic', false, null);
            } else if (command === 'underline') {
                document.execCommand('underline', false, null);
            } else if (command === 'list') {
                document.execCommand('insertUnorderedList', false, null);
            }
            updateFormatButtons();
        }

        function updateFormatButtons() {
            const boldButton = document.getElementById('format-bold');
            const italicButton = document.getElementById('format-italic');
            const underlineButton = document.getElementById('format-underline');
            const listButton = document.getElementById('format-list');

            if (document.queryCommandState('bold')) {
                boldButton.classList.add('bg-primary', 'text-background-dark');
            } else {
                boldButton.classList.remove('bg-primary', 'text-background-dark');
            }

            if (document.queryCommandState('italic')) {
                italicButton.classList.add('bg-primary', 'text-background-dark');
            } else {
                italicButton.classList.remove('bg-primary', 'text-background-dark');
            }

            if (document.queryCommandState('underline')) {
                underlineButton.classList.add('bg-primary', 'text-background-dark');
            } else {
                underlineButton.classList.remove('bg-primary', 'text-background-dark');
            }

            if (document.queryCommandState('insertUnorderedList')) {
                listButton.classList.add('bg-primary', 'text-background-dark');
            } else {
                listButton.classList.remove('bg-primary', 'text-background-dark');
            }
        }

        function ensureCleanEditorState() {
            // Fix: If editor is empty and browser thinks it's bold, toggle it off.
            const editor = document.getElementById('note-edit-content');
            if (editor.innerText.trim().length === 0) {
                 if (document.queryCommandState('bold')) {
                     document.execCommand('bold', false, null);
                 }
                 if (document.queryCommandState('italic')) {
                     document.execCommand('italic', false, null);
                 }
                 if (document.queryCommandState('underline')) {
                     document.execCommand('underline', false, null);
                 }
            }
            updateFormatButtons();
        }

        // --- Item Reordering ---
        async function updateItemOrder() {
            const itemElements = [...notesListContainer.children];
            const tx = db.transaction('fs_nodes', 'readwrite');
            
            const promises = itemElements.map(async (el, index) => {
                const nodeId = el.dataset.id;
                const encryptedNode = await tx.store.get(nodeId);
                if (encryptedNode) {
                    const node = decrypt(encryptedNode.data, password);
                    node.order = index;
                    const encryptedData = encrypt(node, password);
                    return tx.store.put({ id: nodeId, data: encryptedData });
                }
                return Promise.resolve();
            });

            await Promise.all(promises);
            await tx.done;
        }


        // --- Event Listeners ---
        function setupDragAndDrop() {
            let draggedItem = null;
            let autoScrollFrame = null;
            let dragClientY = 0;

            const handleDragStart = (e) => {
                const target = e.target.closest('[draggable="true"]');
                if (!target) return;
                draggedItem = target;
                setTimeout(() => {
                    draggedItem.classList.add('dragging', 'no-pointer-events');
                }, 0);
            };

            const handleDragEnd = () => {
                if (autoScrollFrame) {
                    cancelAnimationFrame(autoScrollFrame);
                    autoScrollFrame = null;
                }
                if (!draggedItem) return;
                draggedItem.classList.remove('dragging', 'no-pointer-events');
                document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                updateItemOrder();
                draggedItem = null;
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                dragClientY = e.clientY || (e.touches && e.touches[0].clientY);
                
                const container = e.currentTarget;
                const afterElement = getDragAfterElement(container, dragClientY);
                const folderTarget = e.target.closest('[data-type="folder"]');

                document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));

                if (folderTarget && folderTarget !== draggedItem) {
                    folderTarget.classList.add('drag-over');
                } else if (afterElement) {
                    afterElement.classList.add('drag-over');
                } else {
                    container.classList.add('drag-over');
                }

                // Autoscroll logic
                if (!autoScrollFrame) {
                    const scrollLoop = () => {
                        const scrollThreshold = 80; 
                        const scrollSpeed = 15; 
                        
                        if (dragClientY < scrollThreshold) {
                            window.scrollBy(0, -scrollSpeed);
                            autoScrollFrame = requestAnimationFrame(scrollLoop);
                        } else if (dragClientY > window.innerHeight - scrollThreshold) {
                            window.scrollBy(0, scrollSpeed);
                            autoScrollFrame = requestAnimationFrame(scrollLoop);
                        } else {
                            autoScrollFrame = null;
                        }
                    };
                    scrollLoop();
                }
            };

            const handleDrop = async (e) => {
                e.preventDefault();
                if (!draggedItem) return;

                const folderTarget = e.target.closest('[data-type="folder"]');
                const container = e.currentTarget;

                if (folderTarget && folderTarget !== draggedItem) {
                    const nodeId = draggedItem.dataset.id;
                    const targetFolderId = folderTarget.dataset.id;

                    const encryptedNode = await db.get('fs_nodes', nodeId);
                    if (encryptedNode) {
                        const node = decrypt(encryptedNode.data, password);
                        node.parentId = targetFolderId;
                        const encryptedData = encrypt(node, password);
                        await db.put('fs_nodes', { id: nodeId, data: encryptedData });
                        draggedItem.remove();
                    }
                } else {
                    const afterElement = getDragAfterElement(container, e.clientY);
                    if (afterElement) {
                        container.insertBefore(draggedItem, afterElement);
                    } else {
                        container.appendChild(draggedItem);
                    }
                }
                handleDragEnd();
            };

            notesListContainer.addEventListener('dragstart', handleDragStart);
            notesListContainer.addEventListener('dragend', handleDragEnd);
            notesListContainer.addEventListener('dragover', handleDragOver);
            notesListContainer.addEventListener('drop', handleDrop);
            
            todosListContainer.addEventListener('dragstart', handleDragStart);
            todosListContainer.addEventListener('dragend', handleDragEnd);
            todosListContainer.addEventListener('dragover', handleDragOver);
            todosListContainer.addEventListener('drop', handleDrop);


            function getDragAfterElement(container, y) {
                const draggableElements = [...container.querySelectorAll('[draggable="true"]:not(.dragging)')];
                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = y - box.top - box.height / 2;
                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            }
        }

        async function createNewFolder(type) {
            const folderName = prompt("Enter folder name:");
            if (!folderName || folderName.trim() === '') return;

            const parentId = type === 'note' ? currentNotesFolder : currentTasksFolder;

            const folder = {
                id: `folder-${Date.now()}`,
                parentId: parentId,
                type: 'folder',
                name: folderName.trim(),
                order: Date.now()
            };

            const encryptedFolder = encrypt(folder, password);
            await db.put('fs_nodes', { id: folder.id, data: encryptedFolder });

            if (type === 'note') {
                renderNotesList();
            } else {
                renderTasksList();
            }
        }

        function setupEventListeners() {
            window.addEventListener('hashchange', router);
            navButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    location.hash = `#page-${btn.dataset.page}`;
                });
            });
            document.getElementById('notes-add-new-button').addEventListener('click', () => {
                location.hash = '#page-note-edit';
            });
            document.getElementById('todos-add-new-button').addEventListener('click', () => {
                location.hash = '#page-task-edit';
            });
            document.getElementById('notes-add-new-folder-button').addEventListener('click', () => createNewFolder('note'));
            document.getElementById('todos-add-new-folder-button').addEventListener('click', () => createNewFolder('task'));
            document.getElementById('settings-button').addEventListener('click', () => {
                location.hash = '#page-settings';
            });
            
            // Settings Listeners
            document.getElementById('setting-font').addEventListener('change', (e) => {
                settings.font = e.target.value;
                saveSettings();
            });
            document.getElementById('setting-bg').addEventListener('change', (e) => {
                settings.bg = e.target.value;
                saveSettings();
            });
            document.getElementById('setting-text-color').addEventListener('change', (e) => {
                settings.textColor = e.target.value;
                saveSettings();
            });
            document.getElementById('setting-line-height').addEventListener('change', (e) => {
                settings.lineHeight = e.target.value;
                saveSettings();
            });
            document.getElementById('setting-compact').addEventListener('change', (e) => {
                settings.compact = e.target.checked;
                saveSettings();
            });
            document.getElementById('setting-scale').addEventListener('input', (e) => {
                settings.scale = e.target.value;
                document.getElementById('setting-scale-value').textContent = `${settings.scale}%`;
                saveSettings();
            });

            // Search Listener
            notesSearchInput.addEventListener('input', (e) => {
                currentSearchQuery = e.target.value;
                renderNotesList();
            });

            noteEditForm.addEventListener('submit', saveNote);
            noteEditCancel.addEventListener('click', () => location.hash = `#page-notes-list/${currentNotesFolder}`);
            noteEditDelete.addEventListener('click', () => {
                if (confirm('Are you sure you want to permanently delete this item?')) {
                    const nodeId = `note-${noteEditId.value}`;
                    deleteNote(nodeId);
                    location.hash = `#page-notes-list/${currentNotesFolder}`;
                }
            });
            taskEditForm.addEventListener('submit', saveTask);
            taskEditCancel.addEventListener('click', () => location.hash = `#page-todos-list/${currentTasksFolder}`);
            taskEditDelete.addEventListener('click', async () => {
                if (confirm('Are you sure you want to permanently delete this item?')) {
                    const nodeId = `task-${taskEditId.value}`;
                    await deleteTask(nodeId);
                    location.hash = `#page-todos-list/${currentTasksFolder}`;
                }
            });
            document.getElementById('format-bold').addEventListener('click', () => formatText('bold'));
            document.getElementById('format-italic').addEventListener('click', () => formatText('italic'));
            document.getElementById('format-underline').addEventListener('click', () => formatText('underline'));
            document.getElementById('format-list').addEventListener('click', () => formatText('list'));
            document.getElementById('note-add-image-gallery').addEventListener('click', addImageFromGallery);
            document.getElementById('note-add-image-camera').addEventListener('click', openCamera);
            document.getElementById('capture-image-button').addEventListener('click', captureImage);
            document.getElementById('cancel-camera-button').addEventListener('click', closeCamera);

            const editor = document.getElementById('note-edit-content');
            editor.addEventListener('focus', () => {
                setTimeout(ensureCleanEditorState, 0); 
            });
            editor.addEventListener('click', () => {
                 setTimeout(ensureCleanEditorState, 0);
            });
            editor.addEventListener('input', updateFormatButtons);
            document.addEventListener('selectionchange', () => {
                if (document.activeElement === editor) {
                    updateFormatButtons();
                }
            });
            editor.addEventListener('blur', () => {
                document.getElementById('format-bold').classList.remove('bg-primary', 'text-background-dark');
                document.getElementById('format-italic').classList.remove('bg-primary', 'text-background-dark');
                document.getElementById('format-underline').classList.remove('bg-primary', 'text-background-dark');
                document.getElementById('format-list').classList.remove('bg-primary', 'text-background-dark');
            });

            document.getElementById('note-detail-copy-btn').addEventListener('click', async (e) => {
                const id = e.currentTarget.dataset.id;
                const encryptedNote = await getNoteById(id);
                if (encryptedNote) {
                    const note = decrypt(encryptedNote.data, password);
                    const turndownService = new TurndownService();
                    const markdownContent = turndownService.turndown(note.content);
                    navigator.clipboard.writeText(markdownContent).then(() => {
                        const icon = e.currentTarget.querySelector('.material-symbols-outlined');
                        icon.textContent = 'check';
                        setTimeout(() => {
                            icon.textContent = 'content_copy';
                        }, 1500);
                    }).catch(err => {
                        console.error('Failed to copy text: ', err);
                        alert('Failed to copy note content.');
                    });
                }
            });

            document.body.addEventListener('click', async (e) => {
                if (e.target.closest('.note-copy-btn')) {
                    const button = e.target.closest('.note-copy-btn');
                    const id = button.dataset.id;
                    const encryptedNote = await getNoteById(id);
                    if (encryptedNote) {
                        const note = decrypt(encryptedNote.data, password);
                        const turndownService = new TurndownService();
                        const markdownContent = turndownService.turndown(note.content);
                        navigator.clipboard.writeText(markdownContent).then(() => {
                            const icon = button.querySelector('.material-symbols-outlined');
                            icon.textContent = 'check';
                            setTimeout(() => {
                                icon.textContent = 'content_copy';
                            }, 1500);
                        }).catch(err => {
                            console.error('Failed to copy text: ', err);
                            alert('Failed to copy note content.');
                        });
                    }
                }

                if (e.target.closest('.note-view-btn')) {
                    location.hash = `#page-note-details/${e.target.closest('.note-view-btn').dataset.id}`;
                }
                if (e.target.closest('.note-edit-btn')) {
                    location.hash = `#page-note-edit/${e.target.closest('.note-edit-btn').dataset.id}`;
                }
                if (e.target.closest('.note-delete-btn')) {
                    if (confirm('Are you sure you want to permanently delete this item?')) {
                        await deleteNote(e.target.closest('.note-delete-btn').dataset.id);
                        renderNotesList();
                    }
                }                
                if (e.target.closest('.task-delete-btn')) {
                    if (confirm('Are you sure you want to permanently delete this item?')) {
                        await deleteTask(e.target.closest('.task-delete-btn').dataset.id);
                        renderTasksList();
                    }
                }
                if (e.target.closest('.folder-delete-btn')) {
                    const folderId = e.target.closest('.folder-delete-btn').dataset.id;
                    if (confirm("Are you sure you want to delete this folder and all its contents? This action cannot be undone.")) {
                        await deleteFolderRecursive(folderId);
                        if (location.hash.includes('notes-list')) {
                            renderNotesList();
                        } else {
                            renderTasksList();
                        }
                    }
                }
                if (e.target.closest('.task-edit-btn')) {
                    e.preventDefault();
                    e.stopPropagation();
                    location.hash = `#page-task-edit/${e.target.closest('.task-edit-btn').dataset.id}`;
                }                                
                if (e.target.closest('.task-notes-toggle-btn')) {
                    const button = e.target.closest('.task-notes-toggle-btn');
                    const taskEl = button.closest('.flex.flex-wrap');
                    const notesEl = taskEl.querySelector('.task-notes');
                    const icon = button.querySelector('.material-symbols-outlined');

                    if (notesEl) {
                        notesEl.classList.toggle('hidden');
                        if (notesEl.classList.contains('hidden')) {
                            icon.textContent = 'expand_more';
                        } else {
                            icon.textContent = 'expand_less';
                        }
                    }
                }

                    if (e.target.closest('.task-toggle-btn')) {
                    toggleTask(e.target.closest('.task-toggle-btn').dataset.id);
                }
            });                            
            notesListContainer.addEventListener('change', (e) => {
                if (e.target.classList.contains('note-select-checkbox') || e.target.classList.contains('folder-select-checkbox')) {
                    updateUI(location.hash || '#page-notes-list');
                }
            });
        }

        async function deleteSelectedItems() {
            const selectedNoteCheckboxes = document.querySelectorAll('.note-select-checkbox:checked');
            const selectedFolderCheckboxes = document.querySelectorAll('.folder-select-checkbox:checked');

            if (selectedNoteCheckboxes.length === 0 && selectedFolderCheckboxes.length === 0) {
                alert("No items selected.");
                return;
            }

            if (!confirm("Are you sure you want to delete the selected items? This action cannot be undone.")) {
                return;
            }

            // Delete directly selected notes
            const selectedNoteIds = Array.from(selectedNoteCheckboxes).map(cb => cb.dataset.id);
            if (selectedNoteIds.length > 0) {
                for (const noteId of selectedNoteIds) {
                    const nodeId = `note-${noteId}`;
                    const encryptedNode = await db.get('fs_nodes', nodeId);
                    if (!encryptedNode) continue;
                    const node = decrypt(encryptedNode.data, password);
                    await db.delete('notes', Number(node.itemRefId));
                    await db.delete('fs_nodes', nodeId);
                }
            }

            // Delete selected folders
            if (selectedFolderCheckboxes.length > 0) {
                const selectedFolderIds = Array.from(selectedFolderCheckboxes).map(cb => cb.dataset.id);

                for (const folderId of selectedFolderIds) {
                    await deleteFolderRecursive(folderId);
                }
            }
            
            renderNotesList();
        }

        // --- Import/Export ---
        async function exportNotes() {
            if (!isAuthenticated) return;

            const encryptedNotes = await db.getAll('notes');
            const notes = encryptedNotes.map(n => decrypt(n.data, password)).filter(Boolean);

            if (notes.length === 0) {
                alert("No notes to export.");
                return;
            }

            const jsonString = JSON.stringify(notes, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `pixel-notes-export-${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function getAllNotesInFolder(folderId, allNodes) {
            const notes = [];
            const children = allNodes.filter(n => n.parentId === folderId);

            for (const child of children) {
                if (child.type === 'note') {
                    const encryptedNote = await getNoteById(child.itemRefId);
                    if (encryptedNote) {
                        const note = decrypt(encryptedNote.data, password);
                        if (note) {
                            notes.push(note);
                        }
                    }
                } else if (child.type === 'folder') {
                    const subFolderNotes = await getAllNotesInFolder(child.id, allNodes);
                    notes.push(...subFolderNotes);
                }
            }
            return notes;
        }

        async function exportSelectedNotes() {
            const selectedNoteCheckboxes = document.querySelectorAll('.note-select-checkbox:checked');
            const selectedFolderCheckboxes = document.querySelectorAll('.folder-select-checkbox:checked');

            if (selectedNoteCheckboxes.length === 0 && selectedFolderCheckboxes.length === 0) {
                alert("No items selected.");
                return;
            }

            let notesToExport = [];

            // Get directly selected notes
            const selectedNoteIds = Array.from(selectedNoteCheckboxes).map(cb => Number(cb.dataset.id));
            if (selectedNoteIds.length > 0) {
                const encryptedNotes = await Promise.all(selectedNoteIds.map(id => getNoteById(id)));
                const selectedNotes = encryptedNotes.map(n => decrypt(n.data, password)).filter(Boolean);
                notesToExport.push(...selectedNotes);
            }

            // Get notes from selected folders
            if (selectedFolderCheckboxes.length > 0) {
                const encryptedNodes = await db.getAll('fs_nodes');
                const allNodes = encryptedNodes.map(n => decrypt(n.data, password)).filter(Boolean);
                const selectedFolderIds = Array.from(selectedFolderCheckboxes).map(cb => cb.dataset.id);

                for (const folderId of selectedFolderIds) {
                    const notesInFolder = await getAllNotesInFolder(folderId, allNodes);
                    notesToExport.push(...notesInFolder);
                }
            }
            
            // Remove duplicates
            notesToExport = notesToExport.filter((note, index, self) =>
                index === self.findIndex((t) => (
                    t.id === note.id
                ))
            );

            if (notesToExport.length === 0) {
                alert("No notes to export in selected items.");
                return;
            }

            const format = prompt("Export format (json, txt, or md):")?.toLowerCase();
            if (!format) return;

            let content;
            let fileExtension;

            if (format === 'json') {
                content = JSON.stringify(notesToExport, null, 2);
                fileExtension = 'json';
            } else if (format === 'txt') {
                content = notesToExport.map(n => `# ${n.title}\n\n${stripHTML(n.content)}`).join('\n\n---\n\n');
                fileExtension = 'txt';
            } else if (format === 'md') {
                if (typeof TurndownService === 'undefined') {
                    alert('TurndownService is not available. Cannot export to Markdown.');
                    console.error('TurndownService is not defined.');
                    return;
                }
                const turndownService = new TurndownService();
                content = notesToExport.map(n => `# ${n.title}\n\n${turndownService.turndown(n.content)}`).join('\n\n---\n\n');
                fileExtension = 'md';
            } else {
                alert("Invalid format.");
                return;
            }

            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `pixel-notes-export-${new Date().toISOString().slice(0,10)}.${fileExtension}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function importNotes(event) {
            if (!isAuthenticated) return;
            
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const importedNotes = JSON.parse(e.target.result);
                    if (Array.isArray(importedNotes)) {
                        const tx = db.transaction('notes', 'readwrite');
                        const promises = importedNotes.map((note, index) => {
                            if (note.title) {
                                let noteId = typeof note.id === 'number' ? note.id : Date.now() + index;
                                const encryptedData = encrypt({ ...note, id: noteId }, password);
                                return tx.store.put({ id: noteId, data: encryptedData });
                            }
                            return Promise.resolve();
                        });
                        await Promise.all(promises);
                        await tx.done;
                        
                        renderNotesList();
                        alert(`${importedNotes.length} notes imported successfully!`);
                    } else {
                        alert("Invalid file format.");
                    }
                } catch (error) {
                    alert("Error reading or parsing the file.");
                    console.error("Import error:", error);
                }
            };
            reader.readAsText(file);
        }

        // --- Settings Logic ---
        function loadSettings() {
            const saved = localStorage.getItem('pixel-settings');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    settings = { ...settings, ...parsed };
                } catch (e) {
                    console.error("Failed to load settings", e);
                }
            }
            applySettings();
        }

        function saveSettings() {
            localStorage.setItem('pixel-settings', JSON.stringify(settings));
            applySettings();
        }

        function applySettings() {
            // Font
            const fontClasses = ['font-display', 'font-sans', 'font-serif', 'font-mono', 'font-Inter', 'font-Roboto', 'font-Open-Sans', 'font-Lato', 'font-Montserrat', 'font-Merriweather'];
            document.body.classList.remove(...fontClasses);
            
            let fontClass = settings.font;
            if (fontClass !== 'font-display') {
                 if (!fontClass.startsWith('font-') && fontClass !== 'Inter' && fontClass !== 'Roboto') { 
                     fontClass = 'font-' + fontClass.replace(' ', '-');
                 } else if (!fontClass.startsWith('font-')) {
                     fontClass = 'font-' + fontClass;
                 }
                 document.body.classList.add(fontClass);
            }

            // Background
            const bgClasses = ['bg-solid-black', 'bg-solid-gray', 'bg-midnight', 'bg-forest', 'bg-pattern-grid', 'bg-pattern-dots'];
            document.body.classList.remove(...bgClasses);
            if (settings.bg !== 'bg-default') {
                document.body.classList.add(settings.bg);
            }

            // Text Color
            const textClasses = ['text-white', 'text-gray', 'text-terminal-green', 'text-terminal-amber'];
            document.body.classList.remove(...textClasses);
            if (settings.textColor !== 'text-default') {
                document.body.classList.add(settings.textColor);
            }

            // Line Height
            const lineHeightClasses = ['leading-normal', 'leading-relaxed', 'leading-loose'];
            document.body.classList.remove(...lineHeightClasses);
            document.body.classList.add(settings.lineHeight);

            // Compact
            if (settings.compact) {
                document.body.classList.add('compact-mode');
            } else {
                document.body.classList.remove('compact-mode');
            }

            // Scale
            document.documentElement.style.fontSize = `${settings.scale}%`; 
        }

        function initSettingsUI() {
            document.getElementById('setting-font').value = settings.font;
            document.getElementById('setting-bg').value = settings.bg;
            document.getElementById('setting-text-color').value = settings.textColor;
            document.getElementById('setting-line-height').value = settings.lineHeight;
            document.getElementById('setting-compact').checked = settings.compact;
            document.getElementById('setting-scale').value = settings.scale;
            document.getElementById('setting-scale-value').textContent = `${settings.scale}%`;
        }

        // --- App Initialization ---
        async function main() {
            await initDB();
            loadSettings();
            
            unlockButton.addEventListener('click', handleUnlock);
            passwordInput.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') {
                    handleUnlock();
                }
            });

            document.getElementById('export-button').addEventListener('click', exportNotes);
            document.getElementById('export-selected-button').addEventListener('click', exportSelectedNotes);
            document.getElementById('delete-selected-button').addEventListener('click', deleteSelectedItems);
            document.getElementById('import-button').addEventListener('click', () => {
                document.getElementById('import-file-input').click();
            });
            document.getElementById('import-file-input').addEventListener('change', importNotes);

            registerServiceWorker();
        }

        main();

    </script>
</body>
</html>
